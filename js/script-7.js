// План занятия

// - Callback-функции
// - Замыкание
// - Стрелочные функции

// Всем кому тежяло учиться это нормально это внутрений механизм так реагирует

// - Функция обратного вызова (callback)
// - Функция может принимать другие функции как параметры
// - Функция которая передается другой функции как аргумент называется
// функцией обратного (отложенного) вызова (callback-функция)
// - Функция которая принимает другую функцию как параметр
// или возврашает функцию как результат своей работы называется -
// "функцией высшего порядка"

// Мы с вами писали код который выполняется по строчно
// но большиство нашего кода будет требовать выполнение какого - то кожда по условию

// Функции могут принимать какие-то параметры которые обьявляют и аргументы в эти функции передает

// Мы же можем функцию в переменную записать ? Да. Пожалуйста пример
// const fn1 = function (message, callback) {
//   // Функция это просто значение в JS - а это значит что мы функцию можем передавать как аргументв в другую функцию
//   console.log(message);

//   console.log(callback);
//   callback(100);
//   // произощел вызов функции fn2
// };

// const fn2 = function (number) {
//   // обьявил функцию и кинул как аргумент в функцию fn2 в параметр callback записалась ссылка на эту функцию
//   console.log('Это лог при вызове fn2', number);
// };

// fn1('Hello', fn2);
// я тут передал значение и оно записалось в параметр message и я внутри тело функции использую

// callbeck когда вы передаете он сразу не вызывается он присваивается в параметр и там есть и потом когда тебе нужно ты его вызываешь

// Абстрактный пример переиспользуемой логикой. Пример одну функцию можно кидать в другую.
// const doMath = function (a, b, callback) {
//   const result = callback(a, b);

//   console.log(result);
// };

// const add = function (x, y) {
//   return x + y;
// };

// В переменную мы пишем функции только тогда когда мы хотим их переиспользовать много раз
// const sub = function (x, y) {
//   return x - y;
// };

// doMath(2, 3, add);
// doMath(10, 8, sub);

// Функции могут быть анонимными. пример
// const doMath = function (a, b, callback) {
//   const result = callback(a, b);

//   console.log(result);
// };

// doMath(2, 3, function (x, y) {
//   return x + y;
// }, function() {},);
// doMath(10, 8, function (x, y) {
//   return x - y;
// });
// это литерал функции и нужно привыкать к такой записи
// я передал обьявление функции и передал как третий аргумент
// первый аргумент это 2 второ аргумент 3 а третий аргумент это функция (тело функции) это инлайн функция.
// простыми словами одноразовая функция которую мы используем один раз
// Можно передать еще одну функцию четвертым аргументом и так далее.

// Теперь пример где это применяется
// - Отложенный вызов: регистрация событий
// Пример. Юзкейс 4
// const buttonRef = document.querySelector('.js-button');

// const hardleBtnClick = function () {
//   console.log('Клик по кнопке' + Date.now());
// };

// // чтобы зарегестрировать слушатель событий (добавить слшателя событий)
// buttonRef.addEventListener('click', hardleBtnClick);
// addEventListener() - это добавить слушателя события
// скобки принимаю первым аргументом событие на которм ты хочешь чтобы я выполнил какой-то кусочек кода
// это буквально строка клик а вторым передай мне функцию (кусочек кода) который я буду каждый раз выполнять когда проиходит это событие

// console.log(buttonRef);
// с помощью document.querySelector мы можем получить ссылку на какой-то элемент html (на конпку)

// это единственный способ зарегестрировать выполнение какого-то кода в JS по условию по событию
// мы тут говорим что колбек ты выполнишь (этот кусок кода) тогда когда у тебя произойдет клик по кнопке

// Событие оно отложенное оно произойдет когда-то потом.
// Как написать код кооторый произойдет когда - то потом ? Завернуть его в йункцию и зарегестрировать его как callback

// Пример инлайн функции (пример выше)
// const buttonRef = document.querySelector('.js-button');

// buttonRef.addEventListener('click', function () {
//   console.log('Клик по кнопке' + Date.now());
// });

// Пример. Юзкейс 3
// // Отложенный вызво: геолокауия
// // window.navigator.geolocation
// // Пример
// const onGetPositionSuccess = function (position) {
//   console.log(position);
// };

// const onGetPositionError = function (error) {
//   console.log(error);
// };

// window.navigator.geolocation.getCurrentPosition(
//   onGetPositionSuccess,
//   onGetPositionError
// );
// первый аргумент он вызовет если вы разрешили доступ до своей геолокации
// второй аргумент вызовет если вы отказались давать доступ к геолокации

// Пример
// Юзкейс 2
// Отложенный вызов: интервалы
// Задача. Я хотел бы зарегестрировать функцию которая бы выполнилась через 2 секунды
// const callback = function () {
//   console.log('Через 2 секунды внутри колбека в таймауте');
// };

// console.log('В коде перед таймаутом');

// setTimeout(callback, 2000);
// // это запускает интервал счетсчик времени
// // первым в скобки вы передаете функцию а вторым вы передаете количество милисекунд через которых она будет вызвана 20000 мл это 2 секунды

// console.log('В коде после таймаута');

// Последний пример. работа с бекендом
// Мы писать бекенд не будет на фронтенде мы будем с ним работать. У нас будут 2 модуля с ним
// Чтотакое фронтенд и бекенд? У нас есть браузер и у нас есть сервер в интернете который связан с базой данных
// мы будем делать запрос на сервер, он будет входить в базу данных и возвращать нам результат
// операция отссылки и ответа, запроса и ответа она отложенная, какое-то время проходит
// нам нужно подождать пока придет ответ и по результату этого ответа выполнить какой-то код
// Как это сделать? Завернуть его в функции и передать его как callback

// Отложенный вызов: http-запрос
// - API URL: https://pokeapi.co/api/v2/pokemon
// 1 юзкейс
// const onRequestSuccess = function (response) {
//   console.log('Вызов функции onRequestSuccess после успешкного бекенда'
//   );
//   console.log(response);
// };
// // в эту функцию придет ответ от бекенда

// fetch('https://pokeapi.co/api/v2/pokemon').then(onRequestSuccess);
// спцеально есть встроенный в брацзер фетч  в него кидаешь строку ссылка на сайт (адрес бекенда) и на этот адресс бекенд должен ответить
// и отвечает он в методе зен
// в зен ты передаешь функцию в который он кинет результат этого запроса

// Я вам показал 4 юзкейса где используються колбеки
// 1 юзкейс я обьфил функцию и кинул как кульбек чтобы она была вызвана потом с результаттом работы
// 2 юзкейс я обьявлял йункцию и кадил как колбек чтобы она вызвалась потом через какое-то время
// 3 я обьявлял функцию и кидал их как колбеки чтобы они вызвались потом по результатут раьоты
// 4 я обьявлял йункции и кидал как колбек чтобы она была вызвана по какому-то событию

// Вообще мы делаем функции чтобы передать их куда-то чтобы они там были вызваны когда происходит там тригер какой-то

// у нас будет 1 неделя посвященная перебирающим методам массива это современный методы позволяющие работать с коллекйией примитивов обьектов

// Пример. Функция фильтр для фильтрации массивов
// эта функция будет приминать массив [1, 2, 3, 4, 5] и будет возвращать числа больше 3. Новый масси с числами {3, 4, 5}
// а следующий раз функция должна возвращать мне новый массив с числами меньше 2 [1, 2]
// это операция фильтрация функция по какому-то условию фильтрует массив
// Шаг 1 передать масив
// 2 перебтать массив в цикле чтобы каждый элемент массива сравнить
// шаг 3 также эта функция должна делать новый массив отфильтрованных элементов и возвращать
// щаг 4 чтобы в первом случае функция вернула элемент массивов которые больше или равно трем >= 3
// шаг 5 меньшил или равно 4 <=4
// Проблема? Написать одну функцию которая делает кучу условий невозможно но мы можем передавать в функцию котоорая будет что-то проверять

// const filter = function (array, test1) {
//   const filteredArray = [];

//   for (const el of array) {
//     console.log(el);
//     const passed = test1(el);

//     if (passed) {
//       filteredArray.push(el);
//     }
//   }
//   return filteredArray;
// };

// // Логика проверки
// // 1 передать функцию
// // 2 функция получает элемент массива
// // 3 если елемент массива соответствует условию то функция вернет true
// // 4 если елемент массива  НЕ соответствует условию то функция вернет false
// // наш колюек должне будет проверять условия

// const callback1 = function (value) {
//   return value >= 3;
//   // Операторы сравнения возвращают true или false сами по себе
// };

// const r1 = filter([1, 2, 3, 4, 5], callback1);
// console.log(r1);

// // const r2 = filter([1, 2, 3, 4, 5, 6, 7, 8], function (value) {
// //   return value <= 4;
// // });
// // console.log(r2);
// const callback2 = function (value) {
//   return value <= 4;
// };

// const r2 = filter([1, 2, 3, 4, 5, 6, 7, 8], callback2);
// console.log(r2);

// мы получили функцию фильтр котрая получает произвольный массив и произвольный колбек2
// для каждого оригинального элемента массива вызывается колбек2 и если он возвращает true
// то элемент оригинального массива записывается в финальный массив

// то что мы сейчас написали это маштабируемое решение
// мы можем в йункцию написать любой массив и любой тест и отфильтровать произвольный массив
// Пример. Массив фрукторв
// const fruits = [
//   { name: "apples", quantity: 200, isFresh: true },
//   { name: "grapes", quantity: 150, isFresh: false },
//   { name: "bananas", quantity: 100, isFresh: true },
// ];

// const callback3 = function (fruit) {
//   return fruit.quantity >= 120;
// };

// const r3 = filter(fruits, callback3);
// console.log(r3);

// мы сделали переиспользуемую логику
// мф закрыли создание пустого возврат пустого массива перебор оригианльного массива и для каждого елемента вызов теста и пуш по условию.

// Замыкание в JS - это еще одна концепция
// Функция может принимать другую функцию в себя как аргумент а еще функция может вернуть из себя другую функцию

// Функция результатом своей работы может возвращать другую функцию

// Возвращаемая функция во время вызова будет иметь доступ
// ко всем локальным переменным (области видимости)
// родительской функции (той из которой ее вернули)
// это называется замыкание. Пример ниже.
const fn1 = function (parametr) {
  const innerVariable = "значение внутренней переменной функции fn1";
  // все даелаеться для того чтобы получить доступк к этим внутренним переменным (parametr, innerVariable)

  const innerFunction = function () {
    console.log(parametr);
    console.log(innerVariable);
    console.log("Это вызов функции innerFunction");
  };

  return innerFunction;
};

const fn2 = fn1(555);

fn2();

console.log(fn2);

// Пример 2
const makeDish = function (sheffName, dish) {
  console.log(`${sheffName}, готовит ${dish}`);
};

makeDish("Yaroslav", "пирожок");
makeDish("Yaroslav", "омлет");
makeDish("Yaroslav", "чай");

makeDish("Andrey", "котлеты");
makeDish("Andrey", "суп");
makeDish("Andrey", "кофе");

// Заметдьте у нас разные блюда и поавр тут один а там другой и мы получаем повторение
// Используя замыкание мы можем реализовать другие функции чтобы каждый раз нам не нужно было повторять каждый раз имя повара

const makeSheff = function (name) {
  const makeDish = function (dish) {
    console.log(`${name} готовит ${dish}`);
  };
  return makeDish;
};

const Yaroslav = makeSheff("Yaroslav");

console.log(Yaroslav);

Yaroslav("пирожок");
Yaroslav("чай");

const Andrey = makeSheff("Andrey");

Andrey("котлеты");
Andrey("кофе");
// мі убрали повторение
// у нас было имя и что мы хотим приготовить
// а тепрь мы вызываем нашего шефа и говорим что нам приготовить а имя находиться в замыкании оно там запомнило под капотом

console.log(Andrey);

// Еще один пример

// Округлятор
// Пример. У нас есть число с плавающей точкой
// нам нужно превратить его без точки в целоче число мы используем Math.round()
// если нужно с определенным количеством чисел которых нужно после запятых то используем Number(toFixed(2))

// const floatlingPoint = 3.456789;
// const someInt = Math.round(floatlingPoint);
// const withDecimals = Number(floatlingPoint.toFixed(2));

// const number1 = 3.4567;
// const number2 = 4.5678;
// console.log(Number(number1.toFixed(3)));
// console.log(Number(number2.toFixed(4)));

// const rounder = function (number, places) {
//   return Number(number.toFixed(places));
// };

// console.log(rounder(3.4567, 1));
// console.log(rounder(3.4567, 2));
// console.log(rounder(3.4567, 3));
// мы опять видим повторение мы кидаем число и сколько хотим после запятой чисел
// мф можем это упростить с помощью замыкания
const rounder = function (places) {
  return function (number) {
    return Number(number.toFixed(places));
  };
};

const rounder2 = rounder(2);
const rounder3 = rounder(3);
const rounder4 = rounder(4);
const rounder5 = rounder(1);

console.log(rounder2(3.4567));
console.log(rounder3(3.4567));
console.log(rounder4(3.4567));
console.log(rounder5(3.4567));

// Как закрыть вот это значение замыканием? сложная концепция сейчас в это не вникать. Все придет со временем

// Приватные данные и функции - скрытие реализации, интерфейс.
// Пример с зарплатой. Нам нужно хранить зарплату чтоб никто не мог ее записать.
// Иначе кто-то из нехороших людей может себе напмать зарплату 500.000 грн
// По этому зарплату нужно где-то скрыть
const salaryManagerFactory = function (employeeName, baseSalary = 0) {
  let salary = baseSalary;
  // напрмую изменить salary не полуиться нет доступа к ней

  // const changeBy = function (amount) {
  //   salary += amount;
  // };

  return {
    raise(amount) {
      salary += amount;
    },
    lower(amount) {
      salary -= amount;
    },
    current() {
      return `Текущая зарплата ${employeeName} - ${salary}`;
    },
  };
};

const salaryManager = salaryManagerFactory("Mango", 5000);

console.log(salaryManager.current());

// К замыканию доступа нет это нужно помнить.
// То что лежит в замыкании получить доступ ты не модешь из внешнего кода.

// Напрямую ты можешь записать любое значение в свойство а метод будет тебя как-то ограничить и обойти его логику ты уже не сможешь

// Дальше

// Стрелочные функции
// - Обьявления
// - Явный и неявный возврат
// - Аргументы
// - Неявный возврат обьекта

// Рассмотрим синтаксис стрелочных функций. Со стрелкой немножко меньше писанины получается.
// const add = function (a, b, c) {
//   console.log(a, b, c);
//   return a + b + c;
// };
// console.log(add(5, 10, 15));

// Теперь переписуем этот пример в ввиде стрелки
// const addArrow = (a, b, c) => {
//   // Правила для скобок
//   // если два и больше параметра то скобки обязательно должны быть
// // Если параметр один тогда скобки не обязатльны
//   // const addArrow = a =>
//   // Если параметра вообще нет тогда ставим пустые скобки
//   // const addArrow () =>
//   console.log(a, b, c);
//   return a + b + c;
// };
// console.log(addArrow(5, 10, 15));
// явный возврат потому что у тела больше одной инструкции

// Если в теле функции одна инструкция возврата? То можно упростить и записать как неявный возврат
// const addArrow = (a, b, c) => {
//   return a + b + c;
// };

// console.log(addArrow(5, 10, 15));

// Пример. Как записать функцию в одну строку
// const addArrow = (a, b, c) => a + b + c;
// // тут мі говорим вот тебе функция которая принимает (a, b, c) и она возвращает результат сложения a + b + c;
// // это называеться не явный возврат какого-то выражения математической операции
// // после стрелки мы ставим результат чего нам нужно вернуть

// console.log(addArrow(5, 10, 15));
// стрелочные функции - это удобные однострочные функции

// у стрелочных функций нет локальной переменной аргументс console.log(arguments) вообще
// А как получить доступ ко всем аргументам?
// const addArrow = (...args) => {
//   console.log(args);
//   return a + b + c;
// };

// console.log(addArrow(5, 10, 15));
// // просто ...рестом собирите все аргументы в один массив
// ...рест это когда берете много аргументов и собираете в одни массив
// если в стрелочных функциях нужно собрать все аргументы то через ...рест (сбор)

// Пример.
const fnA = function () {
  return {
    a: 5,
  };
};

console.log(fnA());

const arrowFnA = () => ({ arrowFnA: 5 });
// Если вы хотите из стрелки вернуть обьект то вы его оборачиваете в скобки
console.log(arrowFnA());

// вы самую обычную функцию можете переделать в стрелку
// самая большая выгодна это когда вы используете инлайн функции
// перепишем фильтр на стрелочные функции
const filter = function (array, test1) {
  const filteredArray = [];

  for (const el of array) {
    console.log(el);
    const passed = test1(el);

    if (passed) {
      filteredArray.push(el);
    }
  }
  return filteredArray;
};

// const callback1 = value => value >= 3;

const r1 = filter([1, 2, 3, 4, 5], (value) => value >= 3);
// тут не явный возврат по этому в одну строку у меня вмещаеться и массив и функция дл проверки каждого елемента этого массива
console.log(r1);

// const callback2 = value => value <= 4;

const r2 = filter([1, 2, 3, 4, 5, 6, 7, 8], (value) => value <= 4);
console.log(r2);

const fruits = [
  { name: "apples", quantity: 200, isFresh: true },
  { name: "grapes", quantity: 150, isFresh: false },
  { name: "bananas", quantity: 100, isFresh: true },
];

// const callback3 = fruit => fruit.quantity >= 120;

const r3 = filter(fruits, (fruit) => fruit.quantity >= 120);
console.log(r3);

// Стрелки помогают нам писать меньшее количество кода

// Три концепции сегодняшнего занятия
// 1 Это колбеки. Мы можем одну функцию кинуть в другую и там оно где-то потом под капотом вызовется.
// 2 это замыкание. Если ты из одной функции возвращаешь в другую то эта другая во внешнем коде при вызове получает доступ ко всем локальным переменным родительской.
// 3 это стрелочные функции.

// Современный фронтенд - это как лего тебе просто нужно знать где что взять чтоб у себя заюзать чтобы заработало.
// Фронтенчик это человек который решает бизнес задачи которые приносят деньги компании.
// Это не иследователь который сидит и в теории копается и думает о смысле жизни и пишет свои костыли на лево и на право.
// Костыли ты пишешь сам для себя в свободное время.
